/*
 * OvSensor.c
 *
 *  Created on: 2017Äê9ÔÂ29ÈÕ
 *      Author: BeatsGr
 */

#include "OvSensor.h"
#include "sleep.h"
void Init_Ov5640()
{
	sccb_senddata(0x31,0x03,0x11);// system clock from pad,0x bit[1]
	sccb_senddata(0x30,0x08,0x82);// software reset,0x bit[7]// delay 5ms

	sccb_senddata(0x30,0x08,0x42);// software power down,0x bit[6]
	usleep(5000);
	sccb_senddata(0x31,0x03,0x03);// system clock from PLL,0x bit[1]
	sccb_senddata(0x30,0x17,0xff);// FREX,0x Vsync,0x HREF,0x PCLK,0x D[9:6] output enable
	sccb_senddata(0x30,0x18,0xff);// D[5:0],0x GPIO[1:0] output enable
	sccb_senddata(0x30,0x34,0x1A);// MIPI 10-bit
	sccb_senddata(0x30,0x37,0x13);// PLL root divider,0x bit[4],0x PLL pre-divider,0x bit[3:0]
	sccb_senddata(0x31,0x08,0x01);// PCLK root divider,0x bit[5:4],0x SCLK2x root divider,0x bit[3:2] // SCLK root divider,0x bit[1:0]
	sccb_senddata(0x36,0x30,0x36);
	sccb_senddata(0x36,0x31,0x0e);
	sccb_senddata(0x36,0x32,0xe2);
	sccb_senddata(0x36,0x33,0x12);
	sccb_senddata(0x36,0x21,0xe0);
	sccb_senddata(0x37,0x04,0xa0);
	sccb_senddata(0x37,0x03,0x5a);
	sccb_senddata(0x37,0x15,0x78);
	sccb_senddata(0x37,0x17,0x01);
	sccb_senddata(0x37,0x0b,0x60);
	sccb_senddata(0x37,0x05,0x1a);
	sccb_senddata(0x39,0x05,0x02);
	sccb_senddata(0x39,0x06,0x10);
	sccb_senddata(0x39,0x01,0x0a);
	sccb_senddata(0x37,0x31,0x12);
	sccb_senddata(0x36,0x00,0x08);// VCM control
	sccb_senddata(0x36,0x01,0x33);// VCM control
	sccb_senddata(0x30,0x2d,0x60);// system control
	sccb_senddata(0x36,0x20,0x52);
	sccb_senddata(0x37,0x1b,0x20);
	sccb_senddata(0x47,0x1c,0x50);
	sccb_senddata(0x3a,0x13,0x43);// pre-gain = 1.047x
	sccb_senddata(0x3a,0x18,0x00);// gain ceiling
	sccb_senddata(0x3a,0x19,0xf8);// gain ceiling = 15.5x
	sccb_senddata(0x36,0x35,0x13);
	sccb_senddata(0x36,0x36,0x03);
	sccb_senddata(0x36,0x34,0x40);
	sccb_senddata(0x36,0x22,0x01); // 50/60Hz detection     50/60Hz
	sccb_senddata(0x3c,0x01,0x34);// Band auto,0x bit[7]
	sccb_senddata(0x3c,0x04,0x28);// threshold low sum
	sccb_senddata(0x3c,0x05,0x98);// threshold high sum
	sccb_senddata(0x3c,0x06,0x00);// light meter 1 threshold[15:8]
	sccb_senddata(0x3c,0x07,0x08);// light meter 1 threshold[7:0]
	sccb_senddata(0x3c,0x08,0x00);// light meter 2 threshold[15:8]
	sccb_senddata(0x3c,0x09,0x1c);// light meter 2 threshold[7:0]
	sccb_senddata(0x3c,0x0a,0x9c);// sample number[15:8]
	sccb_senddata(0x3c,0x0b,0x40);// sample number[7:0]
	sccb_senddata(0x38,0x10,0x00);// Timing Hoffset[11:8]
	sccb_senddata(0x38,0x11,0x10);// Timing Hoffset[7:0]
	sccb_senddata(0x38,0x12,0x00);// Timing Voffset[10:8]
	sccb_senddata(0x37,0x08,0x64);
	sccb_senddata(0x40,0x01,0x02);// BLC start from line 2
	sccb_senddata(0x40,0x05,0x1a);// BLC always update
	sccb_senddata(0x30,0x00,0x00);// enable blocks
	sccb_senddata(0x30,0x04,0xff);// enable clocks
	sccb_senddata(0x30,0x0e,0x58);// MIPI power down,0x DVP enable
	sccb_senddata(0x30,0x2e,0x00);
	sccb_senddata(0x43,0x00,0x62);// RGB565
	sccb_senddata(0x50,0x1f,0x01);// ISP RGB
	sccb_senddata(0x44,0x0e,0x00);
	sccb_senddata(0x50,0x00,0xa7); // Lenc on,0x raw gamma on,0x BPC on,0x WPC on,0x CIP on // AEC target
	sccb_senddata(0x3a,0x0f,0x30);// stable range in high
	sccb_senddata(0x3a,0x10,0x28);// stable range in low
	sccb_senddata(0x3a,0x1b,0x30);// stable range out high
	sccb_senddata(0x3a,0x1e,0x26);// stable range out low
	sccb_senddata(0x3a,0x11,0x60);// fast zone high
	sccb_senddata(0x3a,0x1f,0x14);// fast zone low// Lens correction for
	sccb_senddata(0x58,0x00,0x23);
	sccb_senddata(0x58,0x01,0x14);
	sccb_senddata(0x58,0x02,0x0f);
	sccb_senddata(0x58,0x03,0x0f);
	sccb_senddata(0x58,0x04,0x12);
	sccb_senddata(0x58,0x05,0x26);
	sccb_senddata(0x58,0x06,0x0c);
	sccb_senddata(0x58,0x07,0x08);
	sccb_senddata(0x58,0x08,0x05);
	sccb_senddata(0x58,0x09,0x05);
	sccb_senddata(0x58,0x0a,0x08);
	sccb_senddata(0x58,0x0b,0x0d);
	sccb_senddata(0x58,0x0c,0x08);
	sccb_senddata(0x58,0x0d,0x03);
	sccb_senddata(0x58,0x0e,0x00);
	sccb_senddata(0x58,0x0f,0x00);
	sccb_senddata(0x58,0x10,0x03);
	sccb_senddata(0x58,0x11,0x09);
	sccb_senddata(0x58,0x12,0x07);
	sccb_senddata(0x58,0x13,0x03);
	sccb_senddata(0x58,0x14,0x00);
	sccb_senddata(0x58,0x15,0x01);
	sccb_senddata(0x58,0x16,0x03);
	sccb_senddata(0x58,0x17,0x08);
	sccb_senddata(0x58,0x18,0x0d);
	sccb_senddata(0x58,0x19,0x08);
	sccb_senddata(0x58,0x1a,0x05);
	sccb_senddata(0x58,0x1b,0x06);
	sccb_senddata(0x58,0x1c,0x08);
	sccb_senddata(0x58,0x1d,0x0e);
	sccb_senddata(0x58,0x1e,0x29);
	sccb_senddata(0x58,0x1f,0x17);
	sccb_senddata(0x58,0x20,0x11);
	sccb_senddata(0x58,0x21,0x11);
	sccb_senddata(0x58,0x22,0x15);
	sccb_senddata(0x58,0x23,0x28);
	sccb_senddata(0x58,0x24,0x46);
	sccb_senddata(0x58,0x25,0x26);
	sccb_senddata(0x58,0x26,0x08);
	sccb_senddata(0x58,0x27,0x26);
	sccb_senddata(0x58,0x28,0x64);
	sccb_senddata(0x58,0x29,0x26);
	sccb_senddata(0x58,0x2a,0x24);
	sccb_senddata(0x58,0x2b,0x22);
	sccb_senddata(0x58,0x2c,0x24);
	sccb_senddata(0x58,0x2d,0x24);
	sccb_senddata(0x58,0x2e,0x06);
	sccb_senddata(0x58,0x2f,0x22);
	sccb_senddata(0x58,0x30,0x40);
	sccb_senddata(0x58,0x31,0x42);
	sccb_senddata(0x58,0x32,0x24);
	sccb_senddata(0x58,0x33,0x26);
	sccb_senddata(0x58,0x34,0x24);
	sccb_senddata(0x58,0x35,0x22);
	sccb_senddata(0x58,0x36,0x22);
	sccb_senddata(0x58,0x37,0x26);
	sccb_senddata(0x58,0x38,0x44);
	sccb_senddata(0x58,0x39,0x24);
	sccb_senddata(0x58,0x3a,0x26);
	sccb_senddata(0x58,0x3b,0x28);
	sccb_senddata(0x58,0x3c,0x42);
	sccb_senddata(0x58,0x3d,0xce);// lenc BR offset // AWB
	sccb_senddata(0x51,0x80,0xff);// AWB B block
	sccb_senddata(0x51,0x81,0xf2);// AWB control
	sccb_senddata(0x51,0x82,0x00);// [7:4] max local counter,0x [3:0] max fast counter
	sccb_senddata(0x51,0x83,0x14);// AWB advanced
	sccb_senddata(0x51,0x84,0x25);
	sccb_senddata(0x51,0x85,0x24);
	sccb_senddata(0x51,0x86,0x09);
	sccb_senddata(0x51,0x87,0x09);
	sccb_senddata(0x51,0x88,0x09);
	sccb_senddata(0x51,0x89,0x75);
	sccb_senddata(0x51,0x8a,0x54);
	sccb_senddata(0x51,0x8b,0xe0);
	sccb_senddata(0x51,0x8c,0xb2);
	sccb_senddata(0x51,0x8d,0x42);
	sccb_senddata(0x51,0x8e,0x3d);
	sccb_senddata(0x51,0x8f,0x56);
	sccb_senddata(0x51,0x90,0x46);
	sccb_senddata(0x51,0x91,0xf8);// AWB top limit
	sccb_senddata(0x51,0x92,0x04);// AWB bottom limit
	sccb_senddata(0x51,0x93,0x70);// red limit
	sccb_senddata(0x51,0x94,0xf0);// green limit
	sccb_senddata(0x51,0x95,0xf0);// blue limit
	sccb_senddata(0x51,0x96,0x03);// AWB control
	sccb_senddata(0x51,0x97,0x01);// local limit
	sccb_senddata(0x51,0x98,0x04);
	sccb_senddata(0x51,0x99,0x12);
	sccb_senddata(0x51,0x9a,0x04);
	sccb_senddata(0x51,0x9b,0x00);
	sccb_senddata(0x51,0x9c,0x06);
	sccb_senddata(0x51,0x9d,0x82);
	sccb_senddata(0x51,0x9e,0x38);// AWB control // Gamma
	sccb_senddata(0x54,0x80,0x01);// Gamma bias plus on,0x bit[0]
	sccb_senddata(0x54,0x81,0x08);
	sccb_senddata(0x54,0x82,0x14);
	sccb_senddata(0x54,0x83,0x28);
	sccb_senddata(0x54,0x84,0x51);
	sccb_senddata(0x54,0x85,0x65);
	sccb_senddata(0x54,0x86,0x71);
	sccb_senddata(0x54,0x87,0x7d);
	sccb_senddata(0x54,0x88,0x87);
	sccb_senddata(0x54,0x89,0x91);
	sccb_senddata(0x54,0x8a,0x9a);
	sccb_senddata(0x54,0x8b,0xaa);
	sccb_senddata(0x54,0x8c,0xb8);
	sccb_senddata(0x54,0x8d,0xcd);
	sccb_senddata(0x54,0x8e,0xdd);
	sccb_senddata(0x54,0x8f,0xea);
	sccb_senddata(0x54,0x90,0x1d);// color matrix
	sccb_senddata(0x53,0x81,0x1e);// CMX1 for Y
	sccb_senddata(0x53,0x82,0x5b);// CMX2 for Y
	sccb_senddata(0x53,0x83,0x08);// CMX3 for Y
	sccb_senddata(0x53,0x84,0x0a);// CMX4 for U
	sccb_senddata(0x53,0x85,0x7e);// CMX5 for U
	sccb_senddata(0x53,0x86,0x88);// CMX6 for U
	sccb_senddata(0x53,0x87,0x7c);// CMX7 for V
	sccb_senddata(0x53,0x88,0x6c);// CMX8 for V
	sccb_senddata(0x53,0x89,0x10);// CMX9 for V
	sccb_senddata(0x53,0x8a,0x01);// sign[9]
	sccb_senddata(0x53,0x8b,0x98); // sign[8:1] // UV adjust   UV
	sccb_senddata(0x55,0x80,0x06);// saturation on,0x bit[1]
	sccb_senddata(0x55,0x83,0x40);
	sccb_senddata(0x55,0x84,0x10);
	sccb_senddata(0x55,0x89,0x10);
	sccb_senddata(0x55,0x8a,0x00);
	sccb_senddata(0x55,0x8b,0xf8);
	sccb_senddata(0x50,0x1d,0x40);// enable manual offset of contrast// CIP
	sccb_senddata(0x53,0x00,0x08);// CIP sharpen MT threshold 1
	sccb_senddata(0x53,0x01,0x30);// CIP sharpen MT threshold 2
	sccb_senddata(0x53,0x02,0x10);// CIP sharpen MT offset 1
	sccb_senddata(0x53,0x03,0x00);// CIP sharpen MT offset 2
	sccb_senddata(0x53,0x04,0x08);// CIP DNS threshold 1
	sccb_senddata(0x53,0x05,0x30);// CIP DNS threshold 2
	sccb_senddata(0x53,0x06,0x08);// CIP DNS offset 1
	sccb_senddata(0x53,0x07,0x16);// CIP DNS offset 2
	sccb_senddata(0x53,0x09,0x08);// CIP sharpen TH threshold 1
	sccb_senddata(0x53,0x0a,0x30);// CIP sharpen TH threshold 2
	sccb_senddata(0x53,0x0b,0x04);// CIP sharpen TH offset 1
	sccb_senddata(0x53,0x0c,0x06);// CIP sharpen TH offset 2
	sccb_senddata(0x50,0x25,0x00);
	sccb_senddata(0x30,0x08,0x02); // wake up from standby,0x bit[6]

	sccb_senddata(0x30,0x35, 0x41); // PLL
	sccb_senddata(0x30,0x36, 0x69); // PLL
	sccb_senddata(0x3c,0x07, 0x07); // lightmeter 1 threshold[7:0]
	sccb_senddata(0x38,0x20, 0x47); // flip
	sccb_senddata(0x38,0x21, 0x01); // mirror
	sccb_senddata(0x38,0x14, 0x31); // timing X inc
	sccb_senddata(0x38,0x15, 0x31); // timing Y inc
	sccb_senddata(0x38,0x00, 0x00); // HS
	sccb_senddata(0x38,0x01, 0x00); // HS
	sccb_senddata(0x38,0x02, 0x00); // VS
	sccb_senddata(0x38,0x03, 0xfa); // VS
	sccb_senddata(0x38,0x04, 0x0a); // HW (HE)
	sccb_senddata(0x38,0x05, 0x3f); // HW (HE)
	sccb_senddata(0x38,0x06, 0x06); // VH (VE)
	sccb_senddata(0x38,0x07, 0xa9); // VH (VE)
	sccb_senddata(0x38,0x08, 0x05); // DVPHO
	sccb_senddata(0x38,0x09, 0x00); // DVPHO
	sccb_senddata(0x38,0x0a, 0x02); // DVPVO
	sccb_senddata(0x38,0x0b, 0xd0); // DVPVO
	sccb_senddata(0x38,0x0c, 0x07); // HTS
	sccb_senddata(0x38,0x0d, 0x64); // HTS
	sccb_senddata(0x38,0x0e, 0x02); // VTS
	sccb_senddata(0x38,0x0f, 0xe4); // VTS
	sccb_senddata(0x38,0x13, 0x04); // timing V offset
	sccb_senddata(0x36,0x18, 0x00);
	sccb_senddata(0x36,0x12, 0x29);
	sccb_senddata(0x37,0x09, 0x52);
	sccb_senddata(0x37,0x0c, 0x03);
	sccb_senddata(0x3a,0x02, 0x02); // 60Hz max exposure
	sccb_senddata(0x3a,0x03, 0xe0); // 60Hz max exposure
//	sccb_senddata(0x30,0x35, 0x41); // PLL
//	sccb_senddata(0x30,0x36, 0x69); // PLL
//	sccb_senddata(0x3c,0x07, 0x07); // lightmeter 1 threshold[7:0]
//	sccb_senddata(0x38,0x20, 0x47); // flip
//	sccb_senddata(0x38,0x21, 0x01); // mirror
//	sccb_senddata(0x38,0x14, 0x31); // timing X inc
//	sccb_senddata(0x38,0x15, 0x31); // timing Y inc
//	sccb_senddata(0x38,0x00, 0x03); // HS
//	sccb_senddata(0x38,0x01, 0x90); // HS
//	sccb_senddata(0x38,0x02, 0x00); // VS
//	sccb_senddata(0x38,0x03, 0xfa); // VS
//	sccb_senddata(0x38,0x04, 0x06); // HW (HE)
//	sccb_senddata(0x38,0x05, 0xb0); // HW (HE)
//	sccb_senddata(0x38,0x06, 0x04); // VH (VE)
//	sccb_senddata(0x38,0x07, 0xdc); // VH (VE)
//	sccb_senddata(0x38,0x08, 0x02); // DVPHO
//	sccb_senddata(0x38,0x09, 0x80); // DVPHO
//	sccb_senddata(0x38,0x0a, 0x01); // DVPVO
//	sccb_senddata(0x38,0x0b, 0xe0); // DVPVO
//	sccb_senddata(0x38,0x0c, 0x07); // HTS
//	sccb_senddata(0x38,0x0d, 0x64); // HTS
//	sccb_senddata(0x38,0x0e, 0x02); // VTS
//	sccb_senddata(0x38,0x10, 0x00); // VTS
//	sccb_senddata(0x38,0x11, 0x50); // VTS
//	sccb_senddata(0x38,0x12, 0x00); // VTS
//	sccb_senddata(0x38,0x13, 0x16); // timing V offset
//	sccb_senddata(0x36,0x18, 0x00);
//	sccb_senddata(0x36,0x12, 0x29);
//	sccb_senddata(0x37,0x09, 0x52);
//	sccb_senddata(0x37,0x0c, 0x03);
//	sccb_senddata(0x3a,0x02, 0x02); // 60Hz max exposure
//	sccb_senddata(0x3a,0x03, 0xe0); // 60Hz max exposure
	// banding filters are calculated automatically in camera driver
	//sccb_senddata(0x3a08, 0x00); // B50 step
	//sccb_senddata(0x3a09, 0x6f); // B50 step
	//sccb_senddata(0x3a0a, 0x00); // B60 step
	//sccb_senddata(0x3a0b, 0x5c); // B60 step
	//sccb_senddata(0x3a0e, 0x06); // 50Hz max band
	//sccb_senddata(0x3a0d, 0x08); // 60Hz max band
	sccb_senddata(0x3a,0x14, 0x02); // 50Hz max exposure
	sccb_senddata(0x3a,0x15, 0xe0); // 50Hz max exposure
	sccb_senddata(0x40,0x04, 0x02); // BLC line number
	sccb_senddata(0x30,0x02, 0x1c); // reset JFIFO, SFIFO, JPG
	sccb_senddata(0x30,0x06, 0xc3); // disable clock of JPEG2x, JPEG
	sccb_senddata(0x47,0x13, 0x03); // JPEG mode 3
	sccb_senddata(0x44,0x07, 0x04); // Quantization scale
	sccb_senddata(0x46,0x0b, 0x37);
	sccb_senddata(0x46,0x0c, 0x20);
	sccb_senddata(0x48,0x37, 0x16); // MIPI global timing
	sccb_senddata(0x38,0x24, 0x04); // PCLK manual divider
	sccb_senddata(0x50,0x01, 0x83); // SDE on, CMX on, AWB on
	sccb_senddata(0x35,0x03, 0x00); // AEC/AGC on
	//	sccb_senddata(0x30,0x16,0x02); //Strobe output enable
	//	 sccb_senddata(0x3b,0x07,0x0a); //FREX strobe mode1
	//st       robe flash and frame exposure
	sccb_senddata(0x3b,0x00,0x83);              //STROBE CTRL: strobe request ON,0x Strobe mode: LED3
	sccb_senddata(0x3b,0x00,0x00);              //STROBE CTRL: strobe request OFF

	//sccb_senddata(0x50,0x3d,0x82);            //sccb_senddata(0x503d80); test pattern selection control,0x 80:color bar,0x00: test disable
	//sccb_senddata(0x47,0x41,0x01);            //sccb_senddata(0x47401); test pattern enable,0x Test pattern 8-bit
}
void write_i2c(u16 addr,u8 value)
{
	//3ÏàÐ´´«ÊäÖÜÆÚ
	u8 addr1 = addr >> 8;
	u8 addr2 = addr & 0xff;
	sccb_start();									//Æô¶¯SCCB
	sccb_sendbyte(0x78);    //OV6620Éè±¸´ÓµØÖ·£¬Ð´²Ù×÷
	sccb_sendbyte(addr1);
	sccb_sendbyte(addr2);
	sccb_sendbyte(value);         //Ð´Êý¾Ý×Ö½Ú
	sccb_end();                   //½áÊøSCCB

	usleep(2000);
}
//void Init_Ov7725()
//{
//	sccb_senddata(0x12,0x80);		// BIT[7]-Reset all the Reg
//	usleep(100000);
//	//sccb_senddata(0x12, 0x06);
//	//Bingo Init REV
//	//Write Data Index
//	sccb_senddata(0x1c, 0x7f);
//	sccb_senddata(0x1d, 0xa2);
//	sccb_senddata(0x12, 0x80);
//	sccb_senddata(0x3d, 0x03);	//DC offset for analog process
//	sccb_senddata(0x15, 0x00);	//COM10: href/vsync/pclk/data reverse(Vsync H valid)
//	sccb_senddata(0x17, 0x22);	//VGA:	0x22;	QVGA:	0x3f;
//	sccb_senddata(0x18, 0xa4);	//VGA:	0xa4;	QVGA:	0x50;
//	sccb_senddata(0x19, 0x07);	//VGA:	0x07;	QVGA:	0x03;
//	sccb_senddata(0x1a, 0xf0);	//VGA:	0xf0;	QVGA:	0x78;
//	sccb_senddata(0x32, 0x00);	//Bit[7]:Mirror image edge alignment
//	sccb_senddata(0x29, 0xA0);	//VGA:	0xA0;	QVGA:	0xF0
//	sccb_senddata(0x2C, 0xF6);	//VGA:	0xF0;	QVGA:	0x78
//	sccb_senddata(0x0d, 0x41);	//PLL 4x
//	//sccb_senddata(0x2a, 0x00);	//PLL 4x
//	sccb_senddata(0x11, 0x00);	//CLKRC,Finternal clock = Finput clk*PLL multiplier/[(CLKRC[5:0]+1)*2] = 25MHz*4/[(x+1)*2]
//													//00: 50fps, 01:25fps, 03:12.5fps	(50Hz Fliter)
//	sccb_senddata(0x12, 0x06);	//BIT[6]:	0:VGA; 1;QVGA
//													//VGA:	00:YUV; 01:Processed Bayer RGB; 10:RGB;	11:Bayer RAW; BIT[7]-Reset all the Reg
//	sccb_senddata(0x0c, 0xd0);	//COM3: Bit[6]:Horizontal mirror image ON/OFF, Bit[0]:Color bar; Default:0x10
//	//DSP control
//	sccb_senddata(0x42, 0x7f);	//BLC Blue Channel Target Value, Default: 0x80
//	sccb_senddata(0x4d, 0x09);	//BLC Red Channel Target Value, Default: 0x80
//	sccb_senddata(0x63, 0xf0);	//AWB Control
//	sccb_senddata(0x64, 0xff);	//DSP_Ctrl1:
//	sccb_senddata(0x65, 0x00);	//DSP_Ctrl2:
//	sccb_senddata(0x66, 0x00);	//{COM3[4](0x0C), DSP_Ctrl3[7]}:00:YUYV;	01:YVYU;	[10:UYVY]	11:VYUY
//	sccb_senddata(0x67, 0x00);	//DSP_Ctrl4:[1:0]00/01: YUV or RGB; 10: RAW8; 11: RAW10
//
//	//AGC AEC AWB
//	sccb_senddata(0x13, 0xff);
//	sccb_senddata(0x0f, 0xc5);
//	sccb_senddata(0x14, 0x11);
//	sccb_senddata(0x22, 0x98);	//Banding Filt er Minimum AEC Value; Default: 0x09
//	sccb_senddata(0x23, 0x03);	//Banding Filter Maximum Step
//	sccb_senddata(0x24, 0x40);	//AGC/AEC - Stable Operating Region (Upper Limit)
//	sccb_senddata(0x25, 0x30);	//AGC/AEC - Stable Operating Region (Lower Limit)
//	sccb_senddata(0x26, 0xa1);	//AGC/AEC Fast Mode Operating Region
//	sccb_senddata(0x2b, 0x00);	//TaiWan: 0x00:60Hz Filter; Mainland: 0x9e:50Hz Filter
//	sccb_senddata(0x6b, 0xaa);	//AWB Control 3
//	sccb_senddata(0x13, 0xff);	//0xff: AGC AEC AWB Enable; 0xf0: AGC AEC AWB Disable;
//
//
//	//sccb_senddata(0x0d, 0x41); //20141206
//
//	//matrix sharpness brightness contrast UV
//	sccb_senddata(0x90, 0x0a);
//	sccb_senddata(0x91, 0x01);
//	sccb_senddata(0x92, 0x01);
//	sccb_senddata(0x93, 0x01);
//	sccb_senddata(0x94, 0x5f);
//	sccb_senddata(0x95, 0x53);
//	sccb_senddata(0x96, 0x11);
//	sccb_senddata(0x97, 0x1a);
//	sccb_senddata(0x98, 0x3d);
//	sccb_senddata(0x99, 0x5a);
//	sccb_senddata(0x9a, 0x1e);
//	sccb_senddata(0x9b, 0x3f);	//Brightness
//	sccb_senddata(0x9c, 0x25);
//	sccb_senddata(0x9e, 0x81);
//	sccb_senddata(0xa6, 0x06);
//	sccb_senddata(0xa7, 0x65);
//	sccb_senddata(0xa8, 0x65);
//	sccb_senddata(0xa9, 0x80);
//	sccb_senddata(0xaa, 0x80);
//
//	//Gamma correction
//	sccb_senddata(0x7e, 0x0c);
//	sccb_senddata(0x7f, 0x16);	//
//	sccb_senddata(0x80, 0x2a);
//	sccb_senddata(0x81, 0x4e);
//	sccb_senddata(0x82, 0x61);
//	sccb_senddata(0x83, 0x6f);
//	sccb_senddata(0x84, 0x7b);
//	sccb_senddata(0x85, 0x86);
//	sccb_senddata(0x86, 0x8e);
//	sccb_senddata(0x87, 0x97);
//	sccb_senddata(0x88, 0xa4);
//	sccb_senddata(0x89, 0xaf);
//	sccb_senddata(0x8a, 0xc5);
//	sccb_senddata(0x8b, 0xd7);
//	sccb_senddata(0x8c, 0xe8);
//	sccb_senddata(0x8d, 0x20);
//	//sccb_senddata(0x1c, 0x7f);//20141206
//	sccb_senddata(0x0e, 0x65);//20141206
//}

void SCL1()
{
	Write_pin(55,1);
}
void SCL0()
{
	Write_pin(55,0);
}
void SDA1()
{
	Write_pin(54,1);
}
void SDA0()
{
	Write_pin(54,0);
}

void sccb_start(void)
{
	SCL1();
	SDA1();
	usleep(10);
	SDA0();
	usleep(10);
	SCL0();
	usleep(10);
}

void sccb_end(void)
{
	SDA0();
	usleep(10);
	SCL1();
	usleep(10);
	SDA1();
	usleep(10);
}

void sccb_sendword(u16 value)
{
	unsigned char  i=0;

	for(i=0; i<16; i++)
	{
			if(value & 0x8000 )
				SDA1();
			else
				SDA0();

		 usleep(10);
		 SCL1();
		 usleep(10);
		 SCL0();
		 usleep(10);
		// DATA_LOW();
		 //usleep(10);

		 value<<=1;
	 }

	 //µÚ9Î»£¬Don¡¯t Care
	 SDA0();
	 usleep(10);
	 SCL1();
	 usleep(10);
	 SCL0();
	 usleep(10);
}
void sccb_sendbyte(u8 value)
{
	//²¢ÐÐÊý¾Ý×ª´®ÐÐÊä³ö£¬´®ÐÐÊý¾ÝÊä³öµÄË³ÐòÎªÏÈ¸ßÎ»ÔÙµÍÎ»
	unsigned char  i=0;

	for(i=0; i<8; i++)
	{
			if(value & 0x80 )
				SDA1();
			else
				SDA0();

		 usleep(10);
		 SCL1();
		 usleep(10);
		 SCL0();
		 usleep(10);
		// DATA_LOW();
		 //usleep(10);

		 value<<=1;
	 }

	 //µÚ9Î»£¬Don¡¯t Care
	 SDA0();
	 usleep(10);
	 SCL1();
	 usleep(10);
	 SCL0();
	 usleep(10);
}

void sccb_senddata(unsigned char subaddr1,unsigned char subaddr2,unsigned char value)
{
	//3ÏàÐ´´«ÊäÖÜÆÚ
	sccb_start();									//Æô¶¯SCCB
	sccb_sendbyte(0x78);    //OV6620Éè±¸´ÓµØÖ·£¬Ð´²Ù×÷
	sccb_sendbyte(subaddr1);       //Éè±¸ÄÚ´æµØÖ·
	sccb_sendbyte(subaddr2);       //Éè±¸ÄÚ´æµØÖ·
	sccb_sendbyte(value);         //Ð´Êý¾Ý×Ö½Ú
	sccb_end();                   //½áÊøSCCB

	usleep(2000);
}
